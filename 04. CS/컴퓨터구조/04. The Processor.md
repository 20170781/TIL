# 4. The Processor

## 4.1 Introduction

### 구현할 MIPS 명령어 집합

- lw (load doubleword), sw (store doubleword)

- add, sub, AND, OR, slt

- bet (branch equal), j (jump)



### 개요

<img width="607" alt="image" src="https://user-images.githubusercontent.com/70627979/180793191-b24a1464-000b-45c2-9d41-2b8993949cb1.png">

1. PC(Program Counter)에 있는 instruction memory 주소로 이동해 명령어 가져옴 (**fetch instruction**)

2. 명령어 필드를 보고 명령어가 사용하는 레지스터 피연산자를 알아내어 읽음 (1~2개, **read register**)

3. 레지스터를 읽은 후, **ALU** 사용 (jump 제외)
   - 적재/저장 명령어: 메모리 주소를 계산하기 위해
   - 산술/논리 명령어: 산술 연산 결과를 구하기 위해
   - 분기 명령어: 비교하기 위해

4. ALU 이후,

   - 적재 명령어: ALU 결과를 주소로 사용하여 메모리에서 레지스터에 적재할 값을 읽음

   - 저장 명령어: 레지스터 값을 메모리에 저장
   - 산술/논리 명렁어: ALU 결과를 레지스터에 write 해야함
   - 분기 명령어: ALU 출력을 사용해 다음 명령어 주소 결정 (왼쪽 덧셈기: 현재 PC + 4, 오른쪽 덧셈기: PC와 분기 변위가 더해진 값)



## 4.2 Logic Design Conventions

- Logic element

  - **Combinational logic**: 데이터 값에 대해 연산을 수행 (output은 input에 의해서만 결정)
    - AND 게이트, ALU 등
  - **State element**: state를 가짐 (Sequential logic, output은 input과 내부 상태에 의해 결정)
    - 레지스터, 메모리 등

  <img width="361" alt="image" src="https://user-images.githubusercontent.com/70627979/180797169-e635b6a4-485e-44b5-a6a8-1cbb35a5dd1b.png">





## 4.3 Building a Datapath

- **Datapath**: 프로세서 안에서 데이터를 가지고 연산하거나 데이터를 저장하는 기능 유닛들은 연결하는 것
  - Memories, Register, ALU, Mux 등
- **PC(Program Counter)**: 실행 중인 명령어의 주소를 가지고 있는 레지스터



### Instruction Fetch

(Instructon Memory access)

1. 현재 PC값이 Instuction Memory의 input 값으로 들어감
2. 해당 instuctions이 output으로 나옴
3. 동시에 현재 PC값 + 4 를 해서 (with Adder), 다음 PC 레지스터에 저장

<img width="318" alt="image" src="https://user-images.githubusercontent.com/70627979/180992986-a5aa2686-ae07-4f8d-a527-e6adf9d8efde.png">



### R-Format Instructions

1. 레지스터 2개가 데이터를 읽음

2. arithmetic/logical operation 수행
3. 결과를 레지스터에 씀

<img width="482" alt="image" src="https://user-images.githubusercontent.com/70627979/180994319-72995ea1-4f7d-4a59-ac3a-2e1d8b2694b0.png">



### Load/Store Instruction

(Data Memory access)

- 메모리에 입력이 들어옴

  - Address

  - 저장을 위해 메모리에 쓸 데이터

- 이 때, **Sign Extension**을 사용해야함 (ALU가 32비트이므로, 16비트 address를 32비트로 확장해야함)

<img width="360" alt="image" src="https://user-images.githubusercontent.com/70627979/180994766-84982dfe-fe8d-4807-822b-cd207116ac34.png">



### Branch Instruction

1. 레지스터에서 operands를 읽고
2. 두 operands의 값을 비교
   - ALU 사용 (두 값을 빼서 Zero 값인지 확인, [같으면 1, 다르면 0])

3. target address를 계산
   1. Sign Extension을 사용해 16 → 32비트로 변경
   2. 2 bits만큼 shift left하여 값을 구함
   3. 2에서 구한 값과 PC + 4한 값을 더하여 target address를 구함

<img width="494" alt="image" src="https://user-images.githubusercontent.com/70627979/180996730-44a8bdfd-f632-42c7-a57d-78c6d22865be.png">



### Composing the Elements

- 가장 간단한 datapath는 모든 명령어를 한 clock cycle에 실행하려고 한다.
  - 그러므로 datapath elements가 두 번 이상 사용될 수 없다.
  - 따라서 Instruction Memory와 Data Memory가 분리된다. 

- MIPS 구조를 위한 단순한 Datapath는 서로 다른 명령어 종류가 사용하는 구성 요소들을 합친 것이다.
  - Mux를 이용해 Mux 결과값에 따라 다른 것들이 실행될 수 있도록 만든다.

- Full Datapath

  <img width="532" alt="image" src="https://user-images.githubusercontent.com/70627979/180998502-0c04d7d5-e96e-4e67-b7e6-522c319057e4.png">

  

## 4.4 A Simple Implementation Scheme

### ALU Control

- 명령어 종류

  - **Load/Store**: F = add

  - **Branch**: F = subtract

  - **R-type**: F depends on funct field

  <img width="251" alt="image" src="https://user-images.githubusercontent.com/70627979/181002679-370692f9-8dfa-4414-9c5c-70c9a8c5e4d1.png">

- 명령어의 funct 필드와 2비트 제어 필드(**ALUOp**)를 입력으로 Combination logic을 사용해 **ALU control** 생성

  <img width="472" alt="image" src="https://user-images.githubusercontent.com/70627979/181003278-25bd4978-a4f3-4eb9-bd52-b33c34559f27.png">



### Main Control Unit

- 명령어에 따라서 레지스터나 각각의 영역이 어떤 연산이 필요한지 정해짐

  <img src="https://user-images.githubusercontent.com/70627979/181004519-7a9187c5-e176-433b-9ab2-5d8b653d3cf5.png" alt="image" style="zoom:33%;" />

  - source register 값을 읽음
  - target register 값을 읽음 (load 제외)
  - R-type의 경우 destination register에 연산의 결과를 씀
    - load는 target register에 읽은 결과를 씀
  - Load/Store, Branch는 address 값을 Sign Extension을 사용해 32비트로 만든 후, 더하기 연산 진행



### Datapath with Control

<img width="569" alt="image" src="https://user-images.githubusercontent.com/70627979/181005481-f15970d0-b1f9-4400-bfce-6941c01fc5d3.png">

#### ALU control

1. [Control]을 통해 명령어의 상위 6bit (opcode)에 의해 ALUOp 2bit 생성
2. 생성된 ALUOp와 명령어의 하위 6bit (funct)이 [ALU control]의 input으로 들어와 Combinational logic을 통해 ALU의 control (4bit)이 생성



#### R-Type Instruction

1. 위 방식으로 ALU control 생성
2. Source register와 Target register의 값을 읽어, 해당되는 값들을 반환하여 ALU의 input 값들로 넣음
   - Mux: 0 (ALUSrc 값이 0)
3. Data Memory를 access하지 않고 ALU에서 나온 연산 값을 Destination register에 write 
   - Mux: 0 (메모리에 접근하지 않았으므로 MemtoReg 값이 0)

4. 다시 register 값이 ALU에 들어감
   - Mux: 0 (ALUSrc 값이 0)
5. R타입은 브랜치 명령어가 아니므로 Zero 값이 0이 되고 And gate를 통해 다시 0이 반환되므로, PC + 4 가 다음 PC 값으로 지정



#### Load Instruction

1. 위 방식으로 ALU control 생성 (그러나 하위 6bit은 사용 X)
2. Source register 값을 읽어 ALU의 첫번째 input으로 넣음
3. 명령어 하위 16bit이 Sign-Extension을 통해 32bit이 되고, ALU의 두번째 input으로 들어감
   - Mux: 1 (ALUSrc 값이 1)
4. ALU 결과값(Data의 address 값)이 Data 메모리로 들어가 데이터를 읽음
5. 읽은 데이터를 Target register에 씀
   - Mux: 1 (MemtoReg 값이 1), Mux: 0 (RegDst 값이 0)
6. Zero 값이 0이고 And gate를 통해 다시 0이 반환되므로, PC + 4 가 다음 PC 값으로 지정



#### Branch-on-Equal Instruction

1. 위 방식으로 ALU control 생성 (그러나 하위 6bit은 사용 X)
2. Source register와 Target register의 값을 읽어, 해당되는 값들을 반환하여 ALU의 input 값들로 넣음
   - Mux: 0 (ALUSrc 값이 0)
3. Zero가 1이면, PC + 4 와 address(확장, shift left 2) 가 합쳐져 다음 PC 값으로 지정
   - Mux: 1 (Branch 값이 1)
4. Zero가 0이면, PC + 4가 다음 PC 값으로 지정



### Implementing Jumps

<img width="481" alt="image" src="https://user-images.githubusercontent.com/70627979/181031780-f8800b49-972b-457f-8113-19f1d85283eb.png">

- 다음 3개 값의 연접을 PC에 저장하면 점프 명령를 구현할 수 있다
  - 현재 PC + 4의 상위 4비트
  - 점프 명령어의 address
  - 비트 00