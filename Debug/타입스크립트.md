# 타입스크립트 디버깅

#### #1 

[오류코드] ts(7053): Element implicitly has an 'any' type because expression of type 

[원인]

타입스크립트는 객체의 프로퍼티를 읽을 때, 키에 `string` 타입이 아닌 `string literal` 타입만 허용한다. 즉, index로 `string`타입인 아무 값이나 올 수 있게 만들었기 때문에 오류가 발생한 것이다.

```ts
type DBType = {
  Comment: typeof Comment;
  Hashtag: typeof Hashtag;
  Image: typeof Image;
  Post: typeof Post;
  User: typeof User;
};

const db: DBType = { Comment, Hashtag, Image, Post, User };

Object.keys(db).forEach((modelName) => {
  db[modelName].init(sequelize);		// db[modelName]에 ts(7053) 오류!
});
```

`string literal`은 `Comment`, `Hashtag`처럼 직접 지정한 문자열 이름을 말한다. (객체에서 키에는 ''를 안써줘도 된다.)

[해결 방법]

`DBType` 타입에 `string`타입의 아무런 키가 들어있는 것처럼 만들어주어 인덱스로 `string` 타입을 주어도 오류가 발생하지 않는다.

```ts
type DBType = {
  Comment: typeof Comment;
  Hashtag: typeof Hashtag;
  Image: typeof Image;
  Post: typeof Post;
  User: typeof User;
  [key: string]: any;	// 추가!
};
```

 [참고 자료] https://soopdop.github.io/2020/12/01/index-signatures-in-typescript/



#### #2

[오류코드] ts(2322): Type 'undefined' is not assignable to type 'string'

[원인]  

비밀번호 보안을 위해 `.env`에 있는 값을 가져왔다. 하지만 타입스크립트에서 해당 변수에 값이 할당되어 있는지 확인할 수 없어 타입을  `string|undefined`으로 판단하여, 직접 지정한 타입 `ConfigItem`의 `password`의 타입인 `string`과 달라 오류가 발생했다.

```ts
type ConfigItem = {
  username: string;
  password: string;
  database: string;
  host: string;
  dialect: 'mysql';
};

development: ConfigItem = {
    username: 'root',
    password: process.env.DB_PASSWORD,	// password에 ts(2322) 오류!
    database: 'olim',
    host: '127.0.0.1',
    dialect: 'mysql',
  },
```

[해결 방법]

타입 단언(type assertion) `as`를 이용해 `string`이라 직접 지정하는 방법도 있지만, 코드를 보다 깔끔하게 만들기 위해 확정 할당 어선셜(Definite Assignment Assertions) `!`를 붙여줘 값이 할당되어 있음을 알려 오류를 해결했다. (`password: process.env.DB_PASSWORD!`)

[참고 자료] https://developer-talk.tistory.com/191



#### #3

[오류코드] ts(2554): An argument for 'callback' was not provided

[원인]  

`req.session.destroy()` 메소드의 argument에 callback 함수를 넣어주지 않아 생기는 오류

```ts
router.post('/logout', isLoggedIn, (req, res) => {
  req.logout();
  req.session.destroy(); // 오류!
  res.send('ok');
});
```

[해결 방법] 

`req.session.destroy()` 메소드를 클릭하여 내부 구조를 확인하고, 오류 처리 콜백 함수가 필요하다는 것을 알게되어 추가해주었다.

```ts
router.post('/logout', isLoggedIn, (req, res) => {
  req.logout();
  req.session.destroy((error) => {
    console.log(error);
  }); // session에 저장된 쿠키와 id 삭제
  res.send('ok');
});
```



#### #4

[오류코드] ts(2532): Object is possibly 'undefined'.

[원인] SSR 구현을 위한 쿠키 설정에서 `axios.defaults.headers.Cookie = ''` 코드를 사용하였는데, `axios.defaults.headers`에 아무런 값이 들어있지 않을 경우 오류가 발생할 수 있고, 비어 있을 가능성이 존재한다고 판단하기 때문에 이를 방지하고자 타입스크립트에서 오류 표시함.

```ts
axios.defaults.headers.Cookie = '';

if (req && cookie) {
    axios.defaults.headers.Cookie = cookie;
}
```

[해결 방법]

조건문을 통해 `axios.defaults.headers`가 존재하는 경우에만 코드가 실행될 수 있도록 만들어 주었다.

```ts
if (axios.defaults?.headers) {
    axios.defaults.headers.Cookie = '';

    if (req && cookie) {
      axios.defaults.headers.Cookie = cookie;
    }
}
```

