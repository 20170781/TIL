# Mechanism: Limited Direct Execution

CPU를 가상화하기 위해 OS는 여러 작업들이 동시에 실행되는 것처럼 보이도록 물리적인 CPU를 공유한다.

→ 구현 핵심 기술: **time sharing**



#### 문제점

- 성능 저하 (Performance)

  시스템에 과중한 오버헤드를 주지 않으면서 가상화 구현

- **제어 문제 (Control)**

  CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행
  제어권 상실 시, 한 프로세스가 영원히 계속 실행되며 접근하면 안되는 정보에 접근할  수 있어진다.



## Direct Execution (직접 실행)

프로그램을 빠르게 실행하기 위해 **Limited Direct Execution (제한적 직접 실행)**을 개발하였다.

여기서 **직접실행**이란, 프로그램을 CPU 상에서 바로 실행시키는 것이다.



### Direct Execution 절차

<img width="709" alt="image" src="https://user-images.githubusercontent.com/70627979/160983551-6000583f-18ee-4413-bf85-fbeef70c23f9.png">



### Direct Execution의 문제점

1. **Restricted Operation** : 중요 연산들을 앱에 전부 맡겨 위험함

2. **Switching Between Processes** : 프로세스 간 스위칭 불가능

   

## 문제1. Restricted Operation

만일 프로세스가 특수한 종류의 연산(restricted operation)을 수행하길 원한다면?

- 디스크 I/O 요청
- CPU or Memory 자원에 대한 추가 할당 요청 등

→ 프로세스가 원하는대로 할 수 있게 방치할 수 있지만, 이는 바람직하지 않음(위험함)



### 해결책: Protected control transfer

: 하드웨어(CPU)에서 privilege modes를 제공

- **User mode**: 하드웨어 자원에 대한 접근 권한이 일부 제한됨
- **Kernel mode**: 컴퓨터의 모든 자원에 대한 접근 권한을 가짐



악영향은 못주게 제한 + 일반적인 앱은 사용 가능하게 허용 
→ 운영체제가 허용하는 방법으로만 하드웨어 사용할 수 있게 제한



### System Call

**User Program에게 핵심 기능만 open **할 수 있게 만들어주는 것으로, 위 구조를 가능하게 하는 핵심 기술이다.



#### Trap instruction

: 시스템 콜을 실행하기 위해서는 프로세스가 제공하는 `trap`이라는 특수 명령어를 실행해야 한다.

- Jump into the kernel (CPU가 커널 코드 실행)
- privilege level을 **kernel mode**로 올림



#### Retrun-from-trap instruction

완료된 후 운영체제에서 `return-from-trap` 명령어를 호출

- Return into the calling user program
- privilege level을 **user mode**로 내림



#### 동작방식 및 절차

kernel code 중 어디를 돌릴지 아래 두 가지로 결정한다.

- **trap table** (system-call number 존재)
- **trap handler** 



<img width="430" alt="image" src="https://user-images.githubusercontent.com/70627979/160983152-bf78bdf7-4ab7-47c7-94ca-9209c8ee2ac8.png" style="zoom: 150%;" >

***PC**: Program Counter, CPU가 어떤 주소에 있는 코드를 실행할지 저장하는 특수한 레지스터

***kernel stack**: user code와 kernel code를 전환할 때 필요한 정보를 담고있는 영역



## 문제2. Switching Between Processes

→ OS는 어떻게 CPU 제어권을 다시 획득하여 프로세스를 전환할 수 있는가?



OS가 프로세스 전환을 위해 CPU 제어권을 얻어오는 방식 두 가지

- **Cooperative Approach**: Wait for system call
- **Non-Cooperative Approach**: OS takes control



### Cooperative Approach (협조 방식)

: 유저 프로세스가 스스로 더이상 CPU를 사용하지 않겠다고 양보하는 **`yield`**와 같은 System Call을 만드는 방법

→ 프로그램에 무한 루프와 같은 문제가 있다면, 시스템이 죽어버리는 문제가 생김



### Non-Cooperative Approach (비협조 방식)

: OS가 **timer interrupt**를 이용해 주기적으로 CPU 제어권을 빼앗아오는 방식



#### A timer interrupt

- 컴퓨터 부팅 시, OS가 timer 시작
- 특정 시간 간격으로 **timer interrupt**를 생성
- timer interrupt가 생기면
  - 현재 실행중인 프로세스 중단
  - 현재 실행중이던 프로그램 state를 임시로 저장
  - OS의 미리 저장된 interrupt handler 실행 



#### interrupt

: 어떤 이벤트가 발생했을 때, Hardware가 OS에 신호를 주는 것

- Hardware interrupt
- Software interrupt (**trap**)

<img width="1120" alt="image" src="https://user-images.githubusercontent.com/70627979/160985900-33a1fec0-fc39-4e70-93be-0499fa3ae6c8.png">



### Saving and Restoring Context

협조적 방식이던 비협조적 방식이던, OS가 CPU 제어권을 다시 획득하면 어떤 프로세스를 실행할지 결정해야 한다. 이 결정은 OS의 **스케줄러(Scheduler)**에 의해 결정된다.

만약 다른 프로세스로 전환하기로 결정되면, OS는 **context switch** 코드를 실행한다.



#### Context Switch

1. **현재 실행중인 프로세스의 레지스터 값을 kernel stack에 저장** (context: 범용 레지스터, PC, kernel stack pointer)

2. **실행될 프로세스의 kernel stack으로부터 레지스터 값 복원**
3. kernel stack을 실행될 kernel stack으로 전환
4. return-from-trap 명령어로 실행될 프로세스가 현재 실행 중인 프로세스가 됨



절차)

<img width="685" alt="image" src="https://user-images.githubusercontent.com/70627979/160988858-11b7325e-b775-48c1-b163-9769d6589bb8.png" style="zoom:150%;" >

### 동시성 문제

interrupt/trap handling 하는 동안 timer interrupt가 동시에 올라온다면?

→ interrupt 처리 중엔 interrupt 끄기 (완벽한 해결책 x)

→ lock을 통해서 해결





참고자료

- 교재 6장
- 수업 내용