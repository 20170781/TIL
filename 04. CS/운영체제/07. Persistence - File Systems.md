# File Systems

## File System

### File System Layers

<img width="655" alt="image" src="https://user-images.githubusercontent.com/70627979/171831808-3fab29b1-0629-4476-8a5d-885e08fe72c5.png" style="zoom:80%;" >

### Storage

Storage를 추상화된 상태로 바라보면 아래 이미지와 같이 생겼으며, 이를 block interface abstraction라고 부른다.

<img width="766" alt="image" src="https://user-images.githubusercontent.com/70627979/171832218-a3282c00-26a2-4d8f-a426-fe49f2771214.png">

- **sector:block = 1:1**
- Operations
  - identify()
  - read()
  - write()



파일 시스템은 아래 요소들에 대한 추상화이다.

- storage 내에서 파일을 어떻게 관리할 것인지
- 데이터를 어디에 저장할 것인지



### Abstraction for Storage

#### File

- 디스크에 저장되어 있는 정보의 집합
- 각 파일이 ***inode number***를 가지고 있음 (unique)



#### Directory

- 디렉토리도 하나의 파일
- file 이름과 inode number 매핑하는 정보를 가진 파일
- Hierarchical directory tree (계층 구조)



### Directory Tree (Directory Hierarchy)

<img width="707" alt="image" src="https://user-images.githubusercontent.com/70627979/171833226-2ab406b2-278a-4ac8-9591-8cea26b1dcf8.png" style="zoom:75%;" >



### File System

- 구성

  - **File contents (data)** : 파일 내용

  - **File attributes (metadata or inode)**
    - file size, owner, time stamps, block locations, ...

  - **File name**
    - file name을 이용해 inode number를 찾음 (inode number로 inode를 찾음)

<img width="230" alt="image" src="https://user-images.githubusercontent.com/70627979/171833882-28e10bd3-33f4-4cac-84e0-63d0557a2d72.png" style="zoom:67%;" >

- 해결할 문제: **A mapping problem**
  - <filename, data, metadata> → <a set of blocks\>
- 목표
  - Performance, Reliability, Scalability



### File Attributes

POSIX 기반 Inode

- file type
- device id
- inode number
- access permission
- number of hard links
- file size



### Pathname Translation

**open ("/a/b/c")**

1. open directory "/"
2. search the directory entry for "a", get location of "a"
3. search the directory entry for "b", get location of "b"
4. search the directory entry for "c", get location of "c"
5. open file "c"

(permissions are checked at each step)



### Ensuring Persistence

→ file system buffers writes into memory ("page/buffer cache")

- 문제점: disk에 반영이 안되는 시점이 존재할 수 있음
- 해결방법: **fsync()**
  - 버퍼에 있는 데이터 중 변경된 부분을 디스크에 flush



### Hard & Symbolic Links

#### Hard Link

: 동일한 Inode를 가리키는 파일 추가

- inode에서 hard links 개수 앎
- link count가 0이 되면 inode가 제거됨
- 동일한 파일 시스템 내에 존재하는 파일들끼리만 hard link 생성 가능 
- 디렉토리는 불가능

<img width="353" alt="image" src="https://user-images.githubusercontent.com/70627979/171838203-191ffaf5-dbbf-4eb5-9701-5e390c5316ee.png" style="zoom:67%;" >



#### Symbolic Link

: 다른 파일을 참조하는 레퍼런스를 가짐

- shortcut (바로가기)

<img width="407" alt="image" src="https://user-images.githubusercontent.com/70627979/171838368-6d702be6-ce04-4f10-b6be-26deb76a7696.png" style="zoom:67%;" >



### File System Mounting

: 파일 시스템을 사용하기 전에 시스템의 특정 위치에 붙여주는 것

- Windows: C:\, D:\
- Unix: 빈 디렉토리에 마운트 가능



## File System Implementation

### VSFS (Very Simple File System)

: 가상의 파일 시스템

#### Data Blocks

- disk를 block들로 나눔
- block size = sector size
- disk block은 데이터를 저장되는데 사용됨
- 일부 block은 파일 시스템의 metadata 저장하는데 사용된다.



#### Inodes

: 각 파일에 대한 정보인 metadata를 inode 자료구조에 저장

- 1개 file의 metadata를 1개 inode에 저장 (1:1)
- inode size는 고정되어 있다.



#### Bitmaps

: block이 사용중인지 표현

- Data bitmap
- Inode bitmap



#### Superblock

: 파일 시스템에 대한 정보



### Allocation Strategies

#### Issues

- fragmentation (external)
- grow file
- sequential access
- random access
- metadata overhead



#### 1) Contiguous Allocation

<img width="611" alt="image" src="https://user-images.githubusercontent.com/70627979/171857218-5e8c2472-676f-4e55-a45f-c1280d6156e9.png">

- **metadata**: <starting block #, length>
- **external fragmentation**: o
- **grow file**: difficult
- **sequential accesses, random accesses**: good 

- **overhead for metadata**: little



#### 2) Linked Allocation

<img width="601" alt="image" src="https://user-images.githubusercontent.com/70627979/171857531-98fe0028-8426-4694-b8d7-3271da8906e5.png">

- metadata: <starting block #>
- 각 block에 다음 block 가리키는 포인터 포함 (공간 낭비)
- **external fragmentation**: x
- **sequential access**: random
- **random access**: bad



#### 3) File Allocation Table (FAT)

<img width="631" alt="image" src="https://user-images.githubusercontent.com/70627979/171857968-2be9fcb3-dec1-4592-87fa-636d553edcb6.png">

- 모든 파일에 대한 연결 리스트 정보를 disk에 있는 FAT에 유지
- FAT은 disk seeks를 피하기 위해 **메인 메모리에 캐싱**되어 있다. (Disk I/O X)
- **metadata**: <starting block #> + FAT
- **random access**: good
- **scalability**:  파일 시스템 크기가 FAT 크기만큼 제한됨



#### 4) Indexed Allocation

<img width="416" alt="image" src="https://user-images.githubusercontent.com/70627979/171858914-c91815e7-e468-4eca-9d3d-7e156844e655.png" style="zoom:67%;" >

- **metadata**: an array of block pointers

- **external fragmentation**: x
- **grow file**: easy
- **sequential access**: data layout에 따라 다름
- **random access**: supported
- **metadata overhead**: large



#### 5) Multi-level Indexing

<img width="485" alt="image" src="https://user-images.githubusercontent.com/70627979/171859631-b710e7e9-9170-4fc2-a6fc-df4f80177eac.png" style="zoom:75%;" >

- data blocks에 대한 pointer의 계층적 동적 할당
- **metadata**: direct pointers (small) + indirect pointers



### Directory Organization

: 디렉토리 또한 파일의 일종



### VSFS (Very Simple File System)

#### Directory

**linear list of <file name, inode number>**

<img width="645" alt="image" src="https://user-images.githubusercontent.com/70627979/171860297-710bf612-647f-4e58-a7df-7afbfe8d7b41.png" style="zoom:67%;" >



#### Reading

<img width="839" alt="image" src="https://user-images.githubusercontent.com/70627979/171866629-60dea4aa-8fae-4a0c-b262-724e85dcd547.png" style="zoom:80%;" >



#### Writing

<img width="835" alt="image" src="https://user-images.githubusercontent.com/70627979/171866701-c740bebc-f79c-4d55-aeff-d16de24ded22.png" style="zoom:80%;" >



#### Caching and Buffering

- read, write files는 I/O 때문에 비용이 많이 듦
- **read**: system memory(DRAM)에 caching
- **write**: write buffering (delay writes)

