# 컴퓨터 구조

- SW를 HW의 특성에 맞게 최적화를 통해 성능향상을 도모

  

## 아키텍처

### 노이만 아키텍처

- 존 폰 노이만이 제안
- **메모리에 명령어와 데이터를 구분하지 않고 저장**
  - 반드시 프로그램 시작주소부터 프로그램이 실행되어야함
  - 명령어와 데이터가 위치에 따라 의미가 달라짐
- 비교적 단순한 구조



### 하버드 아키텍처

- **프로그램 메모리와 데이터 메모리가 분리되어 저장됨**
  - 메모리 주소에 따라 같은 데이터가 의미가 달라지지 않음
- 성능은 좋지만, 비교적 구조가 복잡

<img src="https://user-images.githubusercontent.com/70627979/178201920-56f9ebe6-d4a6-4b5e-8f90-eddf11ed637b.png" alt="image" style="zoom:67%;" />



### 하이브리드 구조

- 오늘날의 컴퓨터 구조
  - **메모리**: 노이만 구조
    → 메모리는 통합해서 하나로 관리
  - **캐시**: 하버드 구조
    → 명령어 캐시 + 데이터 캐시로 분리해서 관리

<img width="583" alt="image" src="https://user-images.githubusercontent.com/70627979/178202264-3308c831-7e40-4478-b826-0ad6d1455343.png">



## 컴퓨터 언어

- **저수준 언어**
  - 기계어(Mnemonic): 기계 명령어의 이진 표현
  - 어셈블리 언어(Assembly): 기계 명령어를 기호 형태로 표현한 것

- **중수준 언어**
  - C, Go
  - H/W에 대한 접근을 어느정도 허용
- **고수준 언어**
  - Java, Python, Javascript
  - H/W에 대한 접근이 거의 불가능



## CISC vs RISC

CPU를 설계하는 방식의 차이



### CISC (Complex Instruction Set Computer)

: 필요한 모든 명령어 셋을 갖추도록 설계

- **명령어마다 실행하는 시간이 다름** (간단한 명령어는 1 사이클, 복잡한 명령어는 4~8 사이클이 필요)

- 대표적인 아키텍처: Intel x86/x86-64



### RISC (Reduced Instruction Set Computer)

: 핵심적인 명령어만으로 명령어 개수를 줄여 실행 시간을 줄이도록 설계

- **명령어마다 실행하는 시간을 동일**하게 만들고, 복잡한 연산은 **조합해서 사용**가능하도록

- 대표적인 아키텍처: ARM / MIPS / RISC-V
- 현재 CPU의 트렌드 방식



|               | CISC     | RISC     |
| ------------- | -------- | -------- |
| 명령어 개수   | 많다     | 적다     |
| 레지스터 개수 | 적다     | 많다     |
| 처리속도      | 느리다   | 빠르다   |
| 내부구조      | 복잡하다 | 간단하다 |
| 전력소모      | 많다     | 적다     |





## 프로그래밍 vs 마이크로 프로그래밍

- **프로그래밍**: 일반적인 의미의 프로그래밍 (고수준~저수준 언어로 코드작성)
- **마이크로 프로그래밍**: 어셈블리 코드를 실행하도록 컴퓨터구조의 각 세부노드(CPU, 레지스터 등)를 조정



## ISA (Instruction Set Architecture)

: 마이크로프로세서(in CPU)가 인식해서 기능을 이해하고 실행할 수 있는 **명령어 집합 구조**

- 명령어 집합 구조에는 제대로 작동하는 이진 기계어 프로그램 작성을 위해 프로그래머가 알아야하는 것들이 모두 포함된다. (명령어, 레지스터, 메모리접근 방식, I/O 장치 등)



## ABI (Application Binary Interface)

: 응용 프로그래머에게 제공되는 기본 명령어 집합과 운영체제 인터페이스를 합친 개념

- 입출력 작업, 메모리 할당 및 기타 저수준 시스템 기능의 세부 사항은 운영체제가 감추어서 응용 프로그래머가 세세한 부분을 걱정하지 않도록 해주는 것이 일반적

<img src="https://user-images.githubusercontent.com/70627979/179446170-dfd5b448-aff2-48de-a1ed-e482bf2c3c0e.png" alt="image" style="zoom:67%;" />



## 메모리 (Memory)

### Volatile

- RAM (Random Access Memory)
  - DRAM (Dynamic Random Access Memory, 메인 메모리)
  - SRAM (Static Random Access Memory, 캐시 메모리)



### Non-Volatile

- ROM (Read Only Memory)
- Flash Memory
  - 보조기억장치
  - DRAM보단 느리지만, 훨씬 싸고 비휘발성
  - NAND, NOR



## 트랜지스터 (Transistor)

: 전기 신호로 on/off 되는 스위치

- 기능: Switch / Amplifier

- **집적 회로**는 수십, 수백 개의 트랜지스터를 칩 하나에 집적시킨 것



## 성능

### 클럭 스피드 (Clock Speed)

**: CPU의 동작속도를 나타내는 척도** (Hz로 표현, 1초당 사이클(or purse) 발생 횟수)

- CPU가 발생시키는 것이 아닌, Oscillator가 발생시킴



### 워드 (Word)

**: CPU가 한 번에 처리가능한 데이터 처리량**

- 대중화된 것은 64bit (한 번에 8byte씩 읽고 처리 가능)



### 실제 처리량 (Throughput/Bandwidth)

**: 워드 * 클럭 스피드**

- bps / Mbps / Gbps / ...
- MB/s, GB/s, ...

→ 실제로는 주어진 클럭 스피드보다 많이 실행하기 위해 한 번에 여러개의 명령어를 동시에 실행시키기 위한 구조 내장

- 멀티 코어 CPU
- 파이프라인
- 슈퍼스케일러



### 성능 평가

- **프로그램의 CPU 실행시간**

  - = 프로그램의 CPU 클럭 사이클 수 x 클럭 사이클 시간
  - = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도

  - = 명령어 개수 x CPI x 클럭 사이클 시간

  - = 명령어 개수 x CPI / 클럭 속도

- **CPI**: 명령어당 평균 클럭 사이클 수 (Clock cycles per instruction)

- 발열 때문에 클럭스피드 무조건 올리는 것은 어려움

- CMOS 기반 반도체는 **동적 에너지**가 주 에너지 소비원인

  - 동적 에너지: 트랜지스터가 0→1, 1→0 으로 바뀔 대 소비되는 에너지

