# CPU Scheduling

지난번에 FIFO, SJF, STCF, RR 스케줄링 기법에 대해 알아봤다. 이 방식들의 한계점을 알아보고, 가장 인기있는 스케줄링 기법인 MLFQ에 대해 알아보자.

## MLFQ 요약

- Rule 1) Priority(A) > Priority(B) 이면, A가 실행된다.

- Rule 2) Priority(A) == Priority(B) 이면, A와 B는 RR 방식으로 실행된다.

- Rule 3) job이 시스템에 들어오면, 가장 높은 우선순위를 배정받음

- Rule 4) 특정 priority level에서 정해진 시간만큼 돌았으면, job의 priority를 1단계 낮춤

- Rule 5) 일정 기간(S) 지나면, 시스템의 모든 job들을 가장 높은 우선순위의 큐로 이동시킴

  

## Goals

- Optimize turnaround time

  : SJF, STCF는 실행시간을 미리 안다는 가정 필요하다.

- Minimize response time for interactive jobs

  : RR은 turnaround time 측면에서 나쁘다.

→ **사전 정보 없이, interactive jobs의 response time을 줄이면서, 동시에 turnaround time도 줄이는 방법**은 없을까?

(workloads의 사전 정보 없이 스케줄링하려면, 실행하는 job이 어떤 특성을 갖는지 과거 경험을 통해 추정해야 한다.)



## MLFQ: Basic Rules

- MLFQ는 여러개의 큐로 구성된다.
  - Multi-Level Feedback Queue
  - 각각의 큐마다 다른 우선순위를 가지고 있다.
- 어떤 하나의 job은 위 큐들 중 하나에 들어가야 한다.



> - #### Rule 1: Priority(A) > Priority(B) 이면, A가 실행된다.
>
> - #### Rule 2: Priority(A) == Priority(B) 이면, A와 B는 RR 방식으로 실행된다.



워크로드가 아래 두 가지로 구성된다고 가정해보자

- Interactive jobs

  - 런타임이 대체로 짧고, response time이 짧길 원함
  - CPU를 사용하는 시간이 짧고, 대부분의 시간을 I/O를 기다리는데 사용

  **→ high priority**

- CPU-intensive jobs

  - CPU를 오랫동안 사용
  - response time을 크게 신경쓰지 않음

  **→ low priority**

<img src="/Users/kanghyun/Library/Application Support/typora-user-images/image-20220404004804811.png" alt="image-20220404004804811" style="zoom: 25%;" />



그러면 job이 어떤 종류인지는 어떻게 구분하는 것일까?

**→ behavior(행동)을 보고 판단!**



## 1. 우선순위 변경

MLFQ 우선순위 결정 알고리즘:

> - #### Rule 3: job이 시스템에 들어오면, 가장 높은 우선순위를 배정받음
>
> - #### Rule 4a: 만약 job이 현재 priority에서 실행했는데 할당된 time-slice를 전부 사용했다면, job의 priority를 1단계 낮춤
>
> - #### Rule 4b: 만약 job이 현재 priority에서 실행했는데 할당된 time-slice를 전부 사용하기 전에 CPU를 양보하면, 그 job은 동일한 priority를 유지함



## 예제

### ex1) A Single Long-Running Job

<img width="814" alt="image" src="https://user-images.githubusercontent.com/70627979/161436957-97fc7373-6062-4a41-90d9-591c8fad928b.png">

### ex2) Along Came a Short Job

(job A가 실행되는 도중 job B가 들어온 상황)

<img width="907" alt="image" src="https://user-images.githubusercontent.com/70627979/161437137-2407745f-2eac-4c01-add9-95930c7874d7.png">

### ex3) I/O가 있는 경우

<img width="808" alt="image" src="https://user-images.githubusercontent.com/70627979/161437251-eebd8aac-00ac-495e-a9cd-1613d34fd093.png">



## Basic MLFQ의 문제점

- **Starvation**

  → 한 시스템에 interactive job들이 너무 많이 존재하면, 낮은 우선순위를 갖는 CPU-intensive job들은 아예 스케줄을 못받는다.

- **Game the scheduler**

  → 앱 개발자가 스케줄러를 속여서 자기 앱만 계속 실행되게 악용할 수 있다. (99%의 time-slice 사용) 

- **A program may changes its behavior over time**

  → 프로그램의 behavior(행동)이 바뀌었음에도 이를 반영하지 못할 수 있다.
  (e.g. 처음엔 CPU 많이 쓰다가, 이후엔 적게 쓰는 것으로 전환되는 경우)



## 2. The Priority Boost (우선순위 상향 조정)

starvation 문제를 해결하기 위해 룰을 추가하였다.

> - #### Rule 5: 일정 기간(S) 지나면, 시스템의 모든 job들을 가장 높은 우선순위의 큐로 이동시킴

<img width="857" alt="image" src="https://user-images.githubusercontent.com/70627979/161437677-f7c2b18f-e282-4040-8b7f-ad64cdbdba05.png" style="zoom: 67%;" >

## 3. Better Accounting (더 나은 시간 측정)

스케줄러 악용 문제를 해결하고자 4번째 룰을 개선하였다.

> - #### Rule 4: 특정 priority level에서 정해진 시간만큼 돌았으면, job의 priority를 1단계 낮춤

→ 각 priority level에서 최대 사용 시간 제한!

<img width="904" alt="image" src="https://user-images.githubusercontent.com/70627979/161437993-defa546f-ab82-4e50-876d-abe23e29037b.png" style="zoom:67%;" >



## Tuning MLFQ and Other Issues

- 높은 우선순위 큐 → 짧은 slice-time
- 낮은 우선순위 큐 → 긴 slice-time

