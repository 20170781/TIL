# Rebase로 문제 해결하기

팀원들끼리 정한 Git 컨벤션에 따라 프로젝트를 진행하던 중 브랜치 병합 과정에서 겪었던 문제와 해결방법을 공유하기 위해 작성했던 글을 옮겨왔다.

(대괄호[] 안에 있는 것은 브랜치 명)

## 문제 발생 과정

1. [epic]에서 빠져나온 [work-1] 작업이 끝나고 PR을 날려 승인을 기다림.

2. [work-2] 작업은 [work-1] 작업한 내용물에 이어서 해야하는데, PR 승인까지 기다리기엔 시간이 아까워 [work-2] 브랜치를 [work-1] 브랜치에서 빼서 작업 진행

   ![image](https://user-images.githubusercontent.com/70627979/161387984-65b9a250-c5e1-4843-9c20-b2cb1d5bf842.png)

3. [work-1] 작업 승인이 떨어져서 `squash merge` 를 하였고, 로컬 환경에서 리모트 브랜치를 pull

4. [work-2]의 커밋 로그가 [work-1] 이후 작업한 것들만 남아있길 바랬는데 [work-1]에서 작업했던 커밋들까지 모두 포함되어 있음 **(문제1)**

   ![image](https://user-images.githubusercontent.com/70627979/161387997-faf1fecf-2467-4fde-821c-25259bff321b.png)

5. 이런 상황인줄 모르고 [work-2]에서 작업한 내용들을 [epic]에 `squash merge` 했더니 병합이 정상적으로 이루어지지 않음 (예를 들어, 아래 이미지를 보면 [work-c]에서 `del workb`라는 커밋을 통해 workb 파일을 지워줬는데, 최상단의 `squash merge`에 대한 커밋 로그를 보면 지웠다는 로그가 없으며, 파일도 그대로 존재한다...!!!)

   ![image](https://user-images.githubusercontent.com/70627979/161388006-460288b8-6cb8-4f6e-9001-b420c6f0309e.png)





## 내가 생각한 해결방안: Rebase

문제 발생과정 4 상황에서, [work-2] 브랜치로 이동하여 [epic] 브랜치를 `rebase` 해준다.

```jsx
$ git rebase epic
```

임의의로 만들었던 git-test 레포에서 `rebase`를 해주었을 때, 아래 이미지와 같이 원하는 결과를 얻을 수 있었다.

![image](https://user-images.githubusercontent.com/70627979/161388025-5de3dba8-778f-4154-bf77-3ca12bf22f01.png)

## 하지만..

이 가설대로라면 `rebase`가 알아서 어디서부터 [work-2]가 커밋한 부분인지 판단해준다는 것이다.

하지만 플젝에서 `rebase` 를 하였을 때, `rebase`가 어디서부터 해당 브랜치가 커밋한 부분인지 알아서 판단하지 못하였고 무한 충돌에 휩싸였었다..ㅠㅠ

(위 이미지로 설명하면, [work-1]에서 커밋한 내용들까지 [work-2] 커밋 로그라고 판단해  `rebase`로 모두 가져오려 해서 문제가 발생한 것!)

> 여기서 @고광서 가 얘기한 내용은, `rebase`할 때 [epic]에서 [work-1]이 `squash merge`된 결과와 [work-1,2]에 있는 모든 커밋들을 비교하기 때문에 충돌이 발생하는 것이라고 한다. @고광서는 rebase가 어디서부터 [work-2]의 커밋인지 알아서 판단해줄 수 없다고 생각한다고 했다!

그렇지만 나는 위 테스트가 정상적으로 진행되는 것을 보고, 다른 부분에서 문제가 있지는 않았을까 생각하였다. 그 전에 우선 위 테스트가 확실히 맞는 것인지 확인하기 위해 파일 구조랑 커밋을 조금 더 복잡하게 만들어서 테스트를 진행해봤다.



## 테스트2

우선 핵심적인 과정은 동일하다. [work-2] 위에서 [work-3]를 작업하였고, [work-2]를 [epic]에 `squash merge`를 해주었다.

이전 테스트와 다른점은 [work-3]에서 file-a를 수정을 3번 진행했고, file-c를 수정 2번 후 삭제해주었다.

![image](https://user-images.githubusercontent.com/70627979/161388068-a94b6d2a-8b33-4556-ad88-c56d8d113386.png)

만약 [work-3]에서 [epic] `rebase`할 때 모든 커밋들을 [epic]에 [work-2]가 `squash merge`된 결과와 비교하는 것이라면 위 커밋들에서 충돌이 발생해 플젝에서 했던 것과 마찬가지로 충돌을 해결해줘야 할 것이었다.

하지만 [work-3]에서 `git rebase epic` 을 날리자 첫 번째 테스트에서 됐던 것처럼 [work-3]에서 또한 정상적으로 `rebase`가 됐다..

(*왜 되는거지? 왜 안되는거지?* 가 동시에 일어난 처참한 상황ㅎ)

![Untitled.png (417×331)](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/fbddce09-6107-4434-8395-159251498ff1/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220402%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220402T143526Z&X-Amz-Expires=86400&X-Amz-Signature=f2d9f5b8cb124a616fa83a10f6a1b9aeead788414c89659bfbc639b6652eb411&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)



### 나의 추측

왜 플젝에서는 `rebase`에서 오류가 발생했을까를 고민하면서 여러 자료들을 찾아보았지만, 관련 자료들을 쉽게 찾지 못하였다. 그래서 추측을 할 수 밖에 없었는데, 내 생각은 아래와 같다.

플젝에서는 이미 [epic]에 `rebase`를 하지않고 `squash merge` 한 내역이 있어서 git이 꼬인 적이 있었는데, 그것 때문에 `rebase`가 작업하던 [work]의 커밋이 어디서부터인지 판단하는데 문제가 생기지 않았을까 추측해본다.



## 결론

우선 팀원들끼리는 `rebase` 방식의 내부 동작원리를 이해하고 결론이 확실히 나기 전까지는 되도록이면 [work] 위에서 새로운 [work]를 만들어 진행하지 않기로 했다.

→ 그리고 팀원끼리 정한 깃 컨벤션 특성 상, 각각의 work는 원래 의존관계 없이 독립적으로 이뤄져야하는게 맞기 때문에 이전 [work]가 `squash merge`될 때까지 다음 [work] 작업을 하지 않는게 맞긴하다.

하지만 만약 열정이 넘쳐서 PR 승인까지 기다리지 못하는 상황이라면, [work-1] 위에 [work-2-copy]를 복사용으로 만들어놓는 방식을 사용하면 좋을 것 같다. 그리고나서 PR 승인이 나면 [epic]에서 [work-2]를 다시 만들어서 위 [work-2-copy]에서 작업한 내용들을 복붙하는 방식으로 진행하면 될 것 같다!