# Hoisting

Hoisting에 대해 간단하게 설명하자면, 우리가 프로그래밍하면서 선언한 모든 선언문들이 코드의 맨 위로 자동으로 올라가고,  그 순서대로 코드가 실행된다고 생각하면 된다. (물론 실제로 코드가 올라가는 것이 아닌 이해를 돕기 위해 올라간다고 표현하는 것이다.)

어떻게 이러한 것이 가능한지 알아보자.

## Variable Hoisting

아래 코드를 다른 언어에서 실행시키면, 변수를 선언 및 할당하기 전에 변수를 사용하였기 때문에 참조 오류(Reference Error)가 뜬다. 하지만 자바스크립트에서는 참조 오류가 뜨지 않고 `undefined` 가 출력된다.

```js
console.log(a); // undefined
var a = 10;
```

왜냐하면 **자바스크립트의 변수 선언 시점이 소스코드가 실행되는 런타임이 아닌, 그 이전 단계인 소스코드 평가 단계에서 이루어지기 때문이다.**

정리하면, 자바스크립트 엔진은 코드를 실행할 때 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체인 실행 컨텍스트를 활성화시키는데, 그 중 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행하는 과정을 호이스팅**이라고 하는 것이다. (물론 호이스팅 단계에서 값이 할당되지는 않는다!)

변수 뿐만 아니라 `var`, `let`, `const`, `function`, `class` 등의 키워드를 사용해 선언되는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다.



### let, const

위 내용만 읽으면, 자바스크립트에서는 호이스팅 때문에 변수를 선언하기 전에 사용해도 오류가 나지 않는다고 생각할 수 있는데, 오류가 나지 않는 것은 호이스팅이 발생하는 것도 있지만, 변수를 선언할 때 `var` 키워드를 사용했기 때문이다.

`var` 키워드는 위처럼 올바른 순서대로 코드를 작성하지 않았음에도 오류를 발생시키지 않기 때문에, 자바스크립트에서는 이를 바로 잡고자 ES6에서는 새로운 변수 선언 키워드인 `let`과 `const`를 도입하였다. (물론 `var` 키워드에는 호이스팅 뿐만이 아니라 여러 문제점이 존재한다.)

이제 아래 코드를 자바스크립트에서 실행시키면 참조 에러(Reference Error)가 발생한다.

```js
console.log(a); // ReferenceError: a is not defined
let a = 10;
```

물론 위 코드에서 오류가 발생한다고 호이스팅이 발생하지 않는 것은 아니다. 호이스팅은 그대로 발생하나 `let`이나 `const` 키워드를 사용했기에 정상적으로 오류가 발생하는 것이다. 

이제 왜 `var` 키워드로 선언한 변수에서는 참조 오류가 발생하지 않았고, `let`, `const` 키워드로 선언한 변수에서는 참조 오류가 발생하는 것일까? 그 이유는 **`var` 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 "선언 단계"와 "초기화 단계"가 한번에 진행**되고, **let, const 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행**되기 때문이다.

즉, `var` 키워드로 선언한 변수는 선언 단계에서 스코프(Lexical Environment)에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알리고, 즉시 초기화 단계에서 `undefined`로 변수를 초기화한다. 그러나 `let`, `const` 키워드로 선언한 변수는 동일하게 선언 단계에 변수의 존재를 알리지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.



## Function Hoisting

함수도 동일하게 호이스팅이 발생하는데, 함수를 정의하는 방식에 따라 동작 방식에 약간의 차이가 있다. 함수를 정의하는 방법 두 가지 함수 선언문과 함수 표현식에 대해 알아보고, 호이스팅이 어떻게 다르게 발생하는지 알아보자.

### 함수 선언문

함수의 **정의부만 존재**하고, 별도의 할당 명령(변수 할당) 없이 함수를 정의하는 방법

```js
function 함수명() { 
    ... 
}
    
// 예시
function plus(a, b) {
    return (a + b);
}
plus(1, 2);
```

**함수 선언문은" 표현식이 아닌 문"이다.** (크롬 개발자 도구의 콘솔에서 함수 선언문 실행하면 완료 값 `undefined`가 출력된다)
만약 선언문이 표현식인 문이라면 완료값 `undefined` 대신에 표현식이 평가되어 생성된 함수가 출력되어야 한다.

함수는 함수명으로 호출할 수 없기 때문에, 함수 선언문으로 정의된 함수는 자바스크립트 엔진이 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.



### 함수 표현식

자바스크립트의 함수는 일급 객체이므로 변수에 할당할 수 있는데, 이 방법을 이용한게 함수 표현식이다. 즉, 함수 리터럴로 생성한 함수 객체를 변수에 할당하여 정의하는 방식이다.

```js
const 식별자 = function() {
	...
}
  
// 예시
const minus = function(a, b) {
    return (a - b);
}
minus(3, 1);
```

**함수 표현식은 "표현식인 문"이다.** 함수명을 추가해줄 수 도 있지만, 생략하는 것이 일반적이다.



## 함수 선언문 vs 함수 표현식

위 변수 호이스팅에서와 마찬가지로, **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.**

```js
plus(10, 2);	// 12
minus(10, 2); // ReferenceError

function plus(a, b) {
    console.log(a + b);
}

const minus = function (a, b) {
    console.log(a - b);
}
```

**함수 선언문으로 정의한 함수는 런타임 이전에 함수 객체가 먼저 생성되고 자바스크립트 엔진에 의해 함수 이름과 동일한 이름의 식별자 생성 및 할당까지 이뤄진다.** 그래서 위 예제처럼 `plus()` 함수를 정의하기 전에 사용했음에도 정상적으로 결과가 출력되는 것이다.

**함수 표현식으로 정의한 함수에 대해서는 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.** 변수 할당문의 값이 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.



> 참고자료
>
> - [모던 자바스크립트 Deep Dive (도서)](http://www.yes24.com/Product/Goods/92742567)