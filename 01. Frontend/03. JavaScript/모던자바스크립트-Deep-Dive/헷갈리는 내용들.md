### 렌더링 (Rendering)

HTML, CSS, JavaScript로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것. 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR)을 가리키기도 한다.



### Ajax (Asynchronous JavaScript and XML)

자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능

=> 서버로부터 필요한 데이터만 전송받아 변경해야하는 부분만 한정적으로 렌더링하는 방식 가능



### Node.js

구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경

브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경. SSR 개발에 주로 사용됨.



### 언매니지드 언어, 매니지드 언어

언매니지드 언어) C언어와 같이 개발자가 명시적으로 메모리를 할당하고 해제하는 저수준 메모리 제어 기능 제공

매니지드 언어) 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당



### 카멜/스네이크/파스칼/헝가리언 케이스

- 카멜 케이스: firstName	=> 변수, 함수 이름
- 스네이크 케이스: first_name
- 파스칼 케이스: FirstName   => 생성자 함수, 클래스 이름
- 헝가리언 케이스: strFirstName, $elem 등



### 값

식(표현식)이 평가되어 생성된 결과



### 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

(리터럴은 평가되어 값을 생성한다.)



### 표현식

값으로 평가될 수 있는 문(statement)

=> 표현식이 평가되면 새로운 값 생성 or 기존 값을 참조



### 표현식인 문, 표현식이 아닌 문

변수에 할당해 판별



### 멀티라인 문자열

일반 문자열 내에서 줄바꿈 허용x -> \로 시작하는 **이스케이프 시퀀스** 사용

템플릿 리터럴 내에서는 그냥 줄바꿈, 공백 허용



### null, undefined

undefined: 자바스크립트 엔진이 변수 초기화할 때 사용하는 값

null: 개발자가 의도적으로 변수에 값이 없다고 명시할 때 사용



### 동적 타입

변수가 선언이 아닌, 할당에 의해 타입이 결정(타입 추론), 그리고 재할당에 의해 변수의 타입이 동적으로 변함(동적 타이핑)



### Object.is()

=== 보다 명확하게 결과를 반환. `Object.is(-0, +0) // false`



### typeof()

string, number, boolean, undefined, symbol, object, function 중 하나 반환



### 블록문 (코드 블록, 블록)

0개 이상의 문을 중괄호로 묶은 것, 하나의 실행 단위로 취급 (제어문, 함수 선언문에 쓰임)



### 타입 변환

- 문자열 : `String()`, `.toString()`
- 숫자: `Number()`, `parseInt(), parseFloat()`(문자열만)

- 불리언: `Boolean()`, `! or !!`



### 객체

- 프로퍼티 삭제: `delete person.age`;

- 동적 키 생성

  ```js
  const key = 'test';
  const obj = {};
  obj[key] = 'hello';	// {test: 'hello'}
  ```

- 계산된 프로퍼티 이름: `person[key + '-' + ++i] = i`



### 유사 배열 객체

배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체

for문으로 순회할 수 있다.

ex) 문자열 (but 변경은 불가능)



### 값에 의한 전달

변수에 할당되는 변수의 원시값이 복사되어 전달되는 것

다른 메모리 공간에 값만 복사되어 전달되므로, 영향을 서로 주지 않는다.

```js
let score = 90;
let copy = score;

let copy = 100;	// score: 90, copy: 100
```



### 참조에 의한 전달

메모리에 저장되어 있는 참조 값을 통해 객체에 접근.

참조 값이 복사되어 전달되기 때문에, 같은 객체를 가리킴.

```
let person = {
	name: 'Lee'
}
let copy = person;
copy.name = 'Kang'	// person.name: 'Kang'
```



### 얕은 복사, 깊은 복사

원본과 다른 별개의 객체 생성

얕은 복사: 객체 한단계 까지만 복사

깊은 복사: 객체에 중첩되어 있는 객체까지 모두 복사



### 화살표 함수

- this 바인딩 방식이 다름
- prototype 프로퍼티 x
- arguments 객체 생성 x



### 콜백 함수 / 고차 함수

콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

고차 함수: 외부에서 콜백 함수를 전달받은 함수



### 순수 함수

어떤 외부 상태에 의존하거나 변경하는 부수 효과가 없는 함수

오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환값을 만듦.

함수의 외부 상태를 변경하지 않음

매개변수를 통해 객체를 전달받으면 비순수 함수가 된다.



### 함수형 프로그래밍

순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임

조건문, 반복문 제거하여 복잡성 해결, 변수 사용 억제, 생명 주기를 최소화

-> 오류를 피하고 프로그램 안정성을 높이려는 것



### 렉시컬 스코프

스코프: 식별자가 유효한 범위

**렉시컬 스코프**: 상위 스코프가 동적으로 변하지 않고, 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정됨.

함수를 어디서 호출했는지가 아닌, 어디서 정의했는지에 따라 상위 스코프를 결정

함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않음.

**함수의 상위 스코프는 언제나 자신이 정의된 스코프**



### 전역 변수의 문제점

- **암묵적 결합**: 모든 코드가 전역 변수를 참조하고 변경할 수 있음
- **긴 생명 주기**: 메모리 리소스가 오랜 기간 소비된다.
- **스코프 체인 상에서 종점에 존재**: 전역 변수의 검색 속도가 가장 느림
- **네임스페이스 오염**: 자바스크립트는 파일이 분리되어 있더라도 하나의 전역 스코프를 공유



### 캡슐화

객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작 메서드를 하나로 묶는 것

캡슐화를 특정 프로퍼티나 메서드를 감출 목적으로 사용할 수 있는데, 이를 정보 은닉이라함.

```js
const Counter = (function() {
	// private 변수
	let num = 0;
	
	return {
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		}
	};
}());

console.log(Counter.num);	// undefined

console.log(Counter.increase());	// 1
console.log(Counter.increase());	// 2
console.log(Counter.decrease());	// 1
```



### 변수 호이스팅

let, const,class를 이용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작하지만, 실제로는 호이스팅이 일어난다. 해당 선언문이 실행되기 전까지 초기화가 일어나지 않기 때문에 동작하지 않는 것처럼 보이는 것 뿐이다.



### 내부 슬롯, 내부 메서드

자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드이다.

직접 접근 및 호출이 불가능하므로 간접적으로 접근해야 한다. ex) `[[Prototype]]` 내부슬롯에 `__proto__` 로 접근



### 프로퍼티 어트리뷰트

자바스크립트 엔진은 프로퍼티 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

- `[[Value]]`: 프로퍼티의 값
- `[[Writeable]]`: 값의 갱신 여부
- `[[Enumerable]]`: 열거 가능 여부
- `[[Configurable]]`: 재정의 가능 여부(삭제, 프로퍼티 어트리뷰트 값의 변경x)

`Object.getOwnPropertyDescriptors(객체)` 메서드를 사용해 간접적으로 확인



### 데이터 프로퍼티와 접근자 프로퍼티

- **데이터 프로퍼티**: 키와 값으로 구성된 일반적인 프로퍼티
- **접근자 프로퍼티**: 자체적으로 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

접근자 프로퍼티는 데이터 프로퍼티와는 다른 프로퍼티 어트리뷰트를 갖는다.

- `[[Get]]` : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 (getter 함수가 호출, 프로퍼티 값이 반환)
- `[[Set]]`: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수(setter 함수 호출, 결과가 프로퍼티 값으로 저장됨)

```js
const person = {
	firstName: 'Ungmo',
	lastName: 'Lee',
	
	get fullName() {
		return `${this.firstName} ${this.LastName}`;
	},
	
	set fullName(name) {
		[this.firstName, this.lastName] = name.split(' ');
	}
}
```

```
person.fullName = 'Kanghyun Lee';
console.log(person);	// {firstName: 'Kanghyun', lastName: 'Lee'}

console.log(person.fullName);	// Kanghyun Lee
```



### 객체 변경 방지

- `Object.preventExtensions`: 객체 확장 금지 (프로퍼티 추가x)
- `Object.seal`: 객체 밀봉 (프로퍼티 삭제x, 프로퍼티 어트리뷰트 재정의x)
- `Object.freeze`: 객체 동결 (프로퍼티 값 쓰기x)

-> 중첩 객체까지 동결은 불가능(재귀적으로 Object.freeze 메서드 호출)



### 생성자 함수로 객체 생성

#### 1. Object 생성자 함수

new Object()

#### 2. 생성자 함수

new 연산자와 함께 함수를 호출하면, 해당 함수는 생성자 함수로 동작함

new 연산자를 사용하지 않으면, 생성자 함수 내부의 this는 전역 객체를 가리킨다.



### 함수도 객체인데 호출 가능한 이유

일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론, 추가로 함수 객체를 위한 `[[Environment]]`, `[[FormalParameters]]` 등의 내부 슬롯과 `[[Call]]`, `[[Construct]]` 같은 내부 메서드를 가지고 있기 때문

일반 함수로서 호출: `[[Call]]`

new 연산자와 함께 생성자 함수로서 호출: `[[Construct]]` -> constructor

함수 선언문, 함수 표현식으로 정의된 함수: constructor

화살표 함수: non-constructor



### 함수 객체의 프로퍼티

함수는 객체이므로, 함수도 프로퍼티를 가질 수 있다.

함수 객체 고유의 프로퍼티: `arguments`, `caller`, `length`, `name`, `prototype` 프로퍼티

- `arguments`: arguments 객체의 프로퍼티로 arguments가 유사배열객체로 보관됨. (그 안에 length 프로퍼티 존재)

  -> Rest 파라미터 도입으로 중요도 떨어짐

- `caller`: 함수 자신을 호출한 함수를 가리킴

- `length`: 함수 정의 시 선언한 매개변수의 개수 (arguments 객체의 length는 호출 시 사용한 인자의 개수 반환)

- `name`: 함수 이름
- `prototype`: constructor 만이 소유하는 프로퍼티 (데이터 프로퍼티)
- `__proto__`접근자 프로퍼티: 모든 객체가 소유한 `[[Prototype]]` 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티



## 프로토타입

자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

### 

### 상속

객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용하는 것

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 **불필요한 중복을 제거**함.

```js
function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.getArea = function() {
    return Math.PI * this.radius ** 2;
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea);	// true
```



### 프로토타입 객체

객체 간 상속을 구현하기 위해 사용

어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드)를 제공하고, 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있다.

모든 객체는 `[[Prototype]]`이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다.



### `__proto__` 접근자 프로퍼티

모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입인 `[[Prototype]]` 내부 슬롯에 간접적으로 접근할 수 있다.

접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 막기 위해서이다.

```
const parent = {};
const child = {};

child.__proto__ = parent;
parent.__proto__ = child;	// TypeError
```

직접 상속을 통해서 Object.prototype을 상속받지 않는 객체를 생성할 수 있기 때문에, `Object.getPrototypeOf`, `Object.setPrototypeOf` 메서드를 추천



### 함수 객체의 prototype 프로퍼티

생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴

non-constructor(화살표 함수, 메서드 축약 표현으로 정의한 메서드는 없음 & 프로토타입도 생성x)

**`__proto__` 접근자 프로퍼티와 함수 객체만 가지고 있는 prototype 프로퍼티는 동일한 프로토타입을 가리킴.**



### 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 생성된다.

사용자 정의 생성자 함수의 경우, 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입이 생성된다.

빌트인 생성자 함수의 경우에는 전역 객체가 생성되는 시점에 생성



### 프로토타입 체인

자바스크립트는 객체의 프로퍼티(메서드)에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없으면 `[[Prototype]]` 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 함. (상속 구현 메커니즘)

`Object.prototype`을 프로토타입 체인의 종점이라 함

`Object.prototype`에서도 프로퍼티를 찾을 수 없을 경우, `undefined`를 반환(오류x)



### 오버라이딩/오버로딩

- 오버라이딩: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용
- 오버로딩: 함수의 이름은 동일하지만, 타입 또는 개수가 다른 메서드를 구현(매개변수에 의해 메서드를 구별하여 호출하는 방식)

하위 객체를 통해 프로토타입의 프로퍼티를 변경 및 삭제는 불가능 

= 하위 객체를 통해 프로퍼티에 get 액세스는 허용, set 액세스는 허용x



### `instanceof` 연산자

```js
객체 instanceof 생성자 함수
```

우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 상에 존재하면 true 반환

**프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아닌, 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인**



### 직접 상속

1. Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체 생성

   - 첫 번째 매개변수: 생성할 객체의 프로토타입으로 지정할 객체

   - 두 번째 매개변수(옵션): 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이루어진 객체



2. 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속

   ```js
   const myProto = { x: 10 };
   const obj = {
   	y: 20,
   	__proto__: myProto
   };
   ```

   

### 정적 프로퍼티/메서드

생성자 함수 고유의 프로퍼티/메서드로, 인스턴스로 참조/호출할 수 없다.

ex)

`Object.create` 메서드는 Object 생성자 함수의 정적 메서드이므로 인스턴스에서 create 메서드를 사용할 수 없다.



### 프로퍼티 존재 확인

#### `in` 연산자

객체 내에 특정 프로퍼티의 존재 여부 확인

`'프로퍼티 키' in 객체`

-> 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인함



#### Reflect.has 메서드

`Reflect.has(객체, '프로퍼티 키')`

in 연산자와 동일하게 작동



#### Object.prototype.hasOwnProperty 메서드

`객체.hasOwnProperty('프로퍼티 키')`

객체 고유의 프로퍼티 키인 경우에만 true 반환



### 프로퍼티 열거

#### `for ... in` 문

```
for (변수선언문 in 객체) {...}

// 예제
for (const key in person) {
	...
}
```

**객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거**

프로퍼티 키가 심벌인 프로퍼티는 열거 x

**객체 자신의 프로퍼티만 열거**하려면 `Object.prototype.hasOwnProperty` 메서드를 사용해야한다.

대부분의 모던 브라우저는 순서를 보장하고, 숫자(실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시함.



배열의 경우, 일반적인 `for`문이나 `for .. of` 문 또는 `Array.prototype.forEach` 메서드 권장 

(배열도 객체이기 때문에 프로퍼티를 가질 수 있고, `for ... in` 문 사용 시 프로퍼티 키가 반복문에 들어온다.)



#### `Object.keys/values/entries` 메서드

객체 고유의 프로퍼티만 열거를 쉽게 하기 위해 사용

- `Object.keys` 메서드는 **객체 자신**의 열거 가능한 **프로퍼티 키**를 **배열**로 반환

- `Object.values` 메서드는 객체 자신의 열거 가능한 **프로퍼티 값**을 배열로 반환

- `Object.entries` 메서드는 객체 자신의 열거 가능한 **프로퍼티 키와 값의 쌍의 배열**을 **배열**에 담아 반환

  ```js
  Object.entries(person)	// [["name", "Lee"], ["address", "Seoul"]]
  ```

  



## 21장 빌트인 객체

### 1. 객체의 분류

- 표준 빌트인 객체: 실행 환경과 관계 없이 사용 가능, 전역 객체의 프로퍼티로서 제공됨.
- 호스트 객체: ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경(브라우저 환경 or Node.js 환경)에서 추가로 제공하는 객체
- 사용자 정의 객체



### 2. 표준 빌트인 객체

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.



### 3. 원시값과 래퍼 객체

문자열이나 숫자, 불리언 등의 원시값이 있음에도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는 원시값을 객체처럼 동작시키기 위함이다.

```js
const str = 'hello'

console.log(str.length);	// 5
```



원시값에 대해 마침표 표기법(or 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값과 연관된 객체를 생성하여 해당 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 돌려놓는다.

문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 **래퍼 객체(wrapper object)**라 한다.



### 4. 전역 객체

전역 객체는 자바스크립트 엔진에 의해 어떤 객체보다 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다.

> ES11에 도입된 `globalThis`는 브라우저 환경과 Node.js 환경에서의 통일된 전역 객체를 가리킨다.



#### 빌트인 전역 프로퍼티

전역 객체의 프로퍼티

- `Infinity`: 무한대를 나타내는 숫자값
- `NaN`: 숫자가 아님을 나타내는 숫자값 NaN을 갖는다.
- `undefined`: 원시 타입 undefined를 값으로 가짐



#### 빌트인 전역 함수

전역 객체의 메서드

- `eval`: 자바스크립트 코드를 나타내는 문자열을 인수로 전달받음

  전달받은 문자열 코드가 표현식이면, 문자열 코드를 런타임에 평가하여 값을 생성

  표현식이 아닌 문이라면, 문자열 코드를 턴타임에 실행

  문자열 코드가 여러 개의 문으로 이루어져있다면, 모든 문을 실행

  ```js
  // 표현식인 문
  eval('1 + 2');	// 3
  
  // 표현식이 아닌 문
  eval('const x = 5');
  console.log(x);	// 5
  
  // 객체 리터럴은 괄호로 둘러싼다.(함수도 마찬가지)
  const o = eval('({a: 1})');
  console.log(o);	// {a: 1}
  ```

  기존의 스코프를 런타임에 동적으로 수정, 그러나 strict mode에서는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.

  (let, const를 사용한 변수 선언문이라면 암묵적으로 strict mode 적용)

  ** 보안에 취약, 속도가 느려 eval 함수는 사용을 금지

- `isFinite`: 전달받은 인수가 정상적인 유한수인지 검사 (boolean 반환)

- `isNan`: 전달받은 인수가 NaN인지 검사 (boolean 반환)

- `parseFloat`: 전달받은 문자열 인수를 실수로 해석하여 반환

  ```js
  parseFloat('3.14');		// 3.14
  parseFloat('34 45 55');	// 34, 공백으로 구분된 문자열은 첫 번째 문자열만 변환
  ```

- `parseInt`: 전달받은 문자열 인수를 정수로 해석하여 반환 (두번째 인자 이용해 n진수를 10진수로 반환 )

- `encodeURI`: 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩

  - 인코딩: URI의 문자들을 이스케이프 처리하는 것
  - 이스케이프 처리: 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환

- `decodeURI`: 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩

- `encodeURIComponent / decodeURIComponent`: =, ?, & 까지 인코딩 및 디코딩



선언하지 않은 식별자에 값을 할당하면, 해당 식별자는 전역 객체의 프로퍼티로 추가된다.

이를 암묵적 전역이라함.



## this

동작을 나타내는 메서드는 프로퍼티를 참조 및 변경할 수 있어야 한다.

프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.

**this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수**

**this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.**

