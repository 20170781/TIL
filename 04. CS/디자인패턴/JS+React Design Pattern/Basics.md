# Basics

## 01. 디자인 패턴 소개

> 패턴
>
> : 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿

<br>

### 1. 디자인 패턴의 이점

- 사용자의 요구에 맞춰 쉽게 **재사용**할 수 있다.
- 정해진 구조와 **공통 표현**을 통한 솔루션을 제공하여 **알아보기 쉬우며 의사소통이 원활해진다.**

- 구조적이고 체계적인 코드를 자연스럽게 작성 가능하다.
- 중복을 줄여 불필요한 **코드의 반복을 피할 수 있다**. (**DRY 원칙** - Don't Repeat Yourself)

<br>



## 02. 패턴선 검증, 프로토 패턴, 그리고 세 가지 법칙

> 새로운 패턴 → 패턴선 검증, 세 가지 법칙 충족 → 디자인 패턴

<br>

### 1. 프로토 패턴

: 패턴성 검증을 모두 통과하지 않은 미숙한 패턴

- **패턴은 '과정'인 동시에 '결과'**
- 패턴을 실제로 적용했을 때 나타나는 구조를 시작적으로 표현할 수 있어야 한다.

<br>

### 2. 패턴성 검증

다음과 특징을 가지고 있으면 '좋은' 패턴으로 간주할 수 있다.

- 단순 원리나 방법만 담고 있는 것이 아닌, **특정 문제를 해결할 수 있다**.
- 해결책을 간접적으로 제공한다.
  - 해석) 특정 문제를 해결하기 위한 구체적인 코드나 구현 방식을 직접 제공하지 않고, 일반적으로 발생하는 문제 상황에 대해 입증된 구조나 방식을 제안하는 설계를 제공 ([링크](https://chatgpt.com/share/d2dac185-fe3d-44ba-a9e4-5ddf06c6b338))

- 설명에 쓰인 대로  잘 작동해야 하며, 확실한 기능만을 말한다.
- 패턴의 공식 설명이 코드와의 관계를 나타내는 심층 구조와 메커니즘을 서술한다.

<br>

### 3. 세 가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상, 또는 문제에 지속적으로 사용되어야 한다. 

이러한 반복성을 입증하려면 세가지 법칙이라고 불리는 다음 질문에 답할 수 있어야 한다.

- **목적 적합성**) 좋은 패턴은 어떻게 판단하나요?
- **유용성**) 좋은 패턴이라고 할 수 있는 이유가 무엇인가요?
- **적용 가능성**) 넓은 적용 범위를가지고 있어 패턴이 될 가치가 있나요?

<br>



## 03. 패턴 구조화 및 작성

### 1. 디자인 패턴 구조

패턴의 설계, 구현 방법 및 목적을 아래 관계성을 고려해 규칙의 형태로 제시

- **컨텍스트**) 패턴이 적용되는 상황
- **집중 목표**) 패턴을 적용할 때 고려해야 하는 목표
- **구성**) 제시된 상황과 고려해야 하는 점들을 해결하는 구성

<br>



## 04. 안티 패턴

### 1. 안티 패턴

: 겉으로만 해결책처럼 생긴 패턴

- 반면교사로 활용하기 위해 문서화하여 기록해야 하는 나쁜 디자인 패턴
- 좋고 나쁨은 상황에 따라 결정된다.

<br>

안티 패턴 관련 두 가지 개념 (by 케이니그, [링크](https://chatgpt.com/share/c9b67794-388b-4528-98c4-d504dd402fe4))

- 문제 상황에 대한 잘못된 해결책
- 문제 상황에서 벗어나 올바른 해결책에 이르는 방법

<br>

### 2. 자바스크립트 안티 패턴

>  신속한 구현을 위해 임시방편 선택 → 임시방편이 영구적으로 이어짐 → 기술 부채, 안티 패턴

- 자바스크립트는 느슨한 타입 언어
- 예시
  - 전역 컨텍스트에서 수많은 변수를 정의하여 전역 네임스페이스 오염*시키기
  - Object 클래스의 프로토타입 수정하기
  - 자바스크립트를 인라인으로 사용하여 유연성 떨어뜨리기

<br>

> *전역 네임스페이스 오염
>
> : 전역 변수나 함수가 너무 많아져서 다른 코드와 충돌하거나 예기치 않은 동작을 초래하는 상황을 의미

<br>



## 05. 최신 자바스크립트 문법과 기능

- 모듈
- 클래스

<br>



## 06. 디자인 패턴의 유형

디자인 패턴은 어떤 문제를 해결하느냐에 따라 다음 세 가지 유형으로 분류된다.

- **생성 패턴**
- **구조 패턴**
- **행위 패턴**

<br>

### 1. 생성 패턴

- 객체를 생성하는 방식과 시점을 제어하는 데 중점
- 객체 생성 과정에서의 복잡성을 숨기고, 객체를 효율적으로 생성하고 관리할 수 있도록 돕는 역할

<br>

### 2. 구조 패턴

- 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점
- 객체 간의 관계를 쉽게 만들고, 클래스와 객체를 확장하거나 변경할 수 있는 유연성을 제공

<br>

### 3. 행위 패턴

- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분산 방법을 정의
- 객체 간의 공통적인 상호작용 패턴을 감지하고 책임을 분배함으로써 상호작용의 유연성을 높이고, 객체의 행위를 추상화한다.

<br>

### 4. 디자인 패턴의 분류

> https://j-su2.tistory.com/25 참고

<img src="https://4z7l.github.io/images/pattern/gof.PNG" alt="img" style="width:75%;" />

<br>

#### 생성 패턴

| 이름                          | 의도                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 팩토리 메소드(Factory Method) | 객체 생성을 서브클래스로 위임하여 캡슐화함                   |
| 추상 팩토리(Abstract Factory) | 구체적인 클래스를 지정하지 않고 인터페이스를 통해 서로 연관되는 객체들을 그룹으로 표현함 |
| 빌더(Builder)                 | 복합 객체의 생성과 표현을 분리하여 동일한 생성 절차에서도 다른 표현 결과를 만들어낼 수 있음 |
| 프로토타입(Prototype)         | 원본 객체를 복사함으로써 객체를 생성함                       |
| 싱글톤(Singleton)             | 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있도록 함 |

<br>

#### 구조 패턴

| 이름                    | 의도                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 어댑터(Adapter)         | 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함 |
| 브리지(Bridge)          | 구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있게 함 |
| 컴포지트(Composite)     | 객체들의 관계를 트리 구조로 구성하여 복합 객체와 단일 객체를 구분없이 다룸 |
| 데코레이터(Decorator)   | 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식 |
| 퍼싸드(Facade)          | 서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스(Wrapper) 제공 |
| 플라이웨이트(Flyweight) | 크기가 작은 여러 개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메모리를 절약함 |
| 프록시(Proxy)           | 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 Surrogate나 Placeholder를 제공 |

<br>

#### 행위 패턴

| 이름                               | 의도                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 책임 연쇄(Chain of Responsibility) | 요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달함 |
| 커맨드(Command)                    | 요청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장함 |
| 인터프리터(Interpreter)            | 특정 언어의 문법 표현을 정의함                               |
| 반복자(Iterator)                   | 내부를 노출하지 않고 접근이 잦은 어떤 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공 |
| 중재자(Mediator)                   | 한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의 |
| 메멘토(Memento)                    | 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화 |
| 옵서버(Observer)                   | 객체 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함 |
| 상태(State)                        | 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용   |
| 전략(Strategy)                     | 동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하도록 함 |
| 템플릿 메소드(Template Method)     | 상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브클래스로 위임함 |
| 방문자(Visitor)                    | 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성함 |