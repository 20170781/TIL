# CPU Scheduling

: 다음에 실행할 프로세스를 정하는 **스케줄링 정책(scheduling policy)**

기본적으로 스케줄링은 아래 두 가지로 분류된다.

- **Non-preemptive scheduling (비선점 스케줄링)**
  - 프로세스가 실행되면 해당 프로세스가 종료되거나 양보할 때까지 계속 실행
  - 협력적으로 동작해야함 (안그러면 하나만 독점함!)

- **Preemptive scheduling (선점형 스케줄링)**
  - 프로세스 실행 도중에도 **OS가 interrupt로 개입** 가능
  - 대부분 이 방식 사용



## 용어

- **Workload**: CPU에서 실행될 작업들의 description (개별: work, 집합: workload)
- **Metric**: 성능 지표 (스케줄링 퀄리티)
- **Scheduler**: 다음에 어떤 프로세스를 실행할지 정의된 로직



## 워크로드에 대한 가정 (Workload Assumptions)

1. 각각의 계산 작업들이 동일한 시간만큼 실행된다.
2. 모든 작업들이 동일한 시간에 도착한다.
3. 한번 실행을 시작하면 연산이 끝날 때까지 할당받은 시간동안 계속 계산한다.
4. 각각의 job들은 CPU 연산만 사용한다.
5. 각각의 job들의 실행시간은 알려져 있다.



## 스케줄링 평가항목 (Scheduling Metrics)

매우 중요!!

1. **반환 시간(turnaround time) = 작업이 완료된 시점 - 도착 시점**
2. **공정성 (fairness)**

3. **응답 시간(response time) = 처음 스케줄된 시점 - 도착 시점**



## 방법1. FIFO Scheduling (First In, First Out)

**: job들이 도착한 순서대로**



### 장점

- 구현이 쉬움
- 위에서 정의한 가정 내에서는 매우 잘 동작함 (하지만 현실에서는 위 가정이 보장되지는 않는다!)

- **no starvation**



### 단점

- Non-preemptive
- 각각의 job들의 실행시간이 다른 경우, 성능이 매우 떨어져 비효율적이다.



### 예제

#### 예제1)

##### 조건) 

- 도착) A, B, C 순으로 0초 (거의 동시에)
- 실행시간) 각각 10초동안

##### 결론)

<img width="369" alt="image" src="https://user-images.githubusercontent.com/70627979/161374035-80c691d3-2cd1-48cd-939f-c9b9901fd61e.png">

- Tt(A) = 10 - 0
- Tt(B) = 20 - 0
- Tt(C) = 30 - 0
- **Average turnaround time = (10 + 20 + 30) / 3 = 20sec**

**(Tt는 turnaround time 계산값)**



#### 예제2)

하지만 위 단점에서 말했던 것처럼, 가정1을 완화시켜 각각의 job들의 실행시간이 다른 경우에는 성능이 매우 떨어져 비효율적이게 된다.

##### 조건)

- 도착) A, B, C 순으로 0초 (거의 동시에)
- 실행시간) A: 100초, B,C: 10초



##### 결론)

<img width="393" alt="image" src="https://user-images.githubusercontent.com/70627979/161374070-13216076-b3f0-4ceb-9408-479e8353959f.png">

- Tt(A) = 100 - 0
- Tt(B) = 110 - 0
- Tt(C) = 120 - 0
- **Average turnaround time = (100 + 110 + 120) / 3 = 110sec**



## 방법2. SJF Scheduling (Shortest Job First)

**: 실행시간이 가장 짧은 job부터 실행**



### 장점

- 실행시간이 달라도 turnaround time 측면에서 나쁘지 않음



### 단점

- Non-preemptive
- 도착시간이 달라지면 FIFO와 비슷한 성능을 가짐



### 예제

#### 예제1)

FIFO 예제2와 동일한 조건이 주어진다고 했을 때, 실행시간이 짧은 B,C 부터 먼저 실행되어 성능이 향상된다.

##### 조건)

- 도착) A, B, C 순으로 0초 (거의 동시에)
- 실행시간) A: 100초, B,C: 10초



##### 결론)

<img width="449" alt="image" src="https://user-images.githubusercontent.com/70627979/161374573-7f0be623-1f8e-426a-a61c-40311a6a0622.png">

- Tt(A) = 120 - 0
- Tt(B) = 10 - 0
- Tt(C) = 20 - 0
- **Average turnaround time = (10 + 20 + 120) / 3 = 50sec**



#### 예제2)

하지만 가정2를 완화시켜 도착시간이 달라지게되면 FIFO와 비슷한 성능을 갖게된다.

##### 조건)

- 도착) A: 0초, B,C: 10초 (거의 동시에), 
- 실행시간) A: 100초, B,C: 10초



##### 결론)

<img width="402" alt="image" src="https://user-images.githubusercontent.com/70627979/161374749-79f18ffc-cc25-42a1-bdfd-d8a6ad01ed89.png">

- Tt(A) = 100 - 0
- Tt(B) = 110 - 10
- Tt(C) = 120 - 10
- **Average turnaround time = (100 + 100 + 110) / 3 = 103.33sec**



## 방법3. STCF Scheduling (Shortest Time-to-Completion First)

**: 남은 실행시간이 가장 짧은 job부터 실행**

- **SJF 스케줄러 방식에 선점형 방식을 추가**한 것이다. (가정3 완화)

- 새로운 job이 도착하면 시스템에 존재하는 job과 새로 들어온 job의 남은 실행시간을 비교하여 적게 남은 것을 선택한다.

- PSJF(Preemptive Shortest Job First)으로도 알려져 있다.



### 장점

- preemptive



### 단점

- 작업의 길이를 미리 알고, job이 CPU만 사용하며, 평가기준이 turnaround time 하나라면 STCF는 문제가 없다.



### 예제

##### 조건)

- 도착) A: 0초, B,C: 10초 (거의 동시에), 
- 실행시간) A: 100초, B,C: 10초



##### 결론)

<img width="400" alt="image" src="https://user-images.githubusercontent.com/70627979/161375096-f68ed6ae-3806-4fd4-9d20-e9dd3487165f.png">

- Tt(A) = 120 - 0
- Tt(B) = 20 - 10
- Tt(C) = 30 - 10
- **Average turnaround time = (120 + 10 + 20) / 3 = 50sec**



## 방법4. RR Scheduling (Round Robin)

: 시간을 잘게 쪼개어 순서대로 번갈아가면서 실행

- FIFO, SJF, STCF 스케줄링 방식들은 모두 **response time** 측면에서 별로이다.
  (응답 시간(response time) = 처음 스케줄된 시점 - 도착 시점)
- circular FIFO queue 라고도 불림



#### time-slice length가 매우 중요!

- shorter
  - better response time
  - context switching이 너무 자주 일어나 오버헤드가 심해져 전체 시스템 성능이 저하됨
- longer
  - worse response time



### 장점

- Preemptive
- No starvation
- good **response time**



### 단점

- bad **turnaround time**



### 예제

SJF/STCF vs RR

##### 조건)

- 도착) A,B,C: 0초 (거의 동시에)
- 실행시간) A,B,C: 5초



##### 결론)

<img width="550" alt="image" src="https://user-images.githubusercontent.com/70627979/161376264-485d2e4c-0e11-43e2-833a-126efcdbf915.png" style="zoom:67%;" >

- SJF/STCF

  - T(average response) = (0 + 5 + 10) / 3 = 5sec

  - T(average turnaround) = (5 + 10 + 15) / 3 = 10sec

- RR (time-slice of 1sec)

  - **T(average response) = (0 + 1 + 2) / 3 = 1sec (good)**

  - **T(average turnaround) = (13 + 14 + 15) / 3 = 14sec (bad)**



## I/O가 있는 경우 (Incorporating I/O)

가정 4를 완화시켜, I/O가 있다고 하고 STCF를 적용시켜보자.

- job이 I/O request 시작 시
  - 해당 job block
  - 다른 job 스케줄됨
- job이 I/O 끝났을 시
  - interrupt 올림
  - 이후에 policy에 의해서 어떤 job을 실행할지 결정



### 예제

중첩이 있을 때와 없을 때를 비교

##### 조건)

- 도착) A,B: 0초 (거의 동시에)
- 실행시간) A,B: 50ms
- 추가) A: 10ms마다 I/O request (A는 10ms만 실행하는 것처럼 스케줄러 작성)



##### 결론)

- 중첩이 없는 경우

  <img width="447" alt="image" src="https://user-images.githubusercontent.com/70627979/161377231-ab173f63-2f26-417a-a77c-d6382c2abe33.png">

  → turnaround time, response time 둘 다 별로

- 중첩이 있는 경우

  <img width="428" alt="image" src="https://user-images.githubusercontent.com/70627979/161377173-98620630-4f83-4d60-a5f5-f07d252de391.png">

  → 훨씬 효율적이다.