# 명령어

컴퓨터 언어에서 단어를 명령어(instruction)라고 하고, 그 어휘를 명령어 집합(instruction set)이라고 한다.



## 명령어 번역

- **Assembler**: 어셈블리 언어를 기계어로 번역
- **Compiler**: 소스코드 전체를 한번에 번역
- **Interpreter**: 소스코드 한줄씩 해석하여 바로 실행



## 명령어 종류

- 레지스터/메모리 주소에 데이터 로드
- 레지스터/메모리 주소에서 읽기/쓰기
- 산술 연산 (arithmetic) - add, subtract
- 논리 연산(logical) - and, or, nor, shift
- 분기(jumb) - 조건(conditional), 무조건(unconditional)



## 피연산자

상위 수준 언어의 프로그램과는 달리, 산술 명령어의 피연산자에는 제약이 있다. **레지스터**라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것 만을 사용할 수 있다. 그리고 CPU에서 여러 개의 레지스터가 한 덩어리로 처리되는 경우가 많은데, 한 번에 처리하는 **데이터 크기(레지스터 개수)**를 Word라고 하며, 보통 8, 16, 32, 64 bit 중 하나이다.

- 변수에 해당하는 레지스터들은 $s1, $s1 등으로 표기



### Word

: CPU가 한 사이클에 처리하는 데이터 크기

- MIP 구조에서는 32bit, 현재 데스크탑/모바일은 64bit

- **Bank**: 램의 데이터 출력 핀 개수와 워드값을 맞추기 위한 개념
  - 램 출력이 8bit인 경우, 32bit 워드와 맞추려면 4개의 램이 필요
- **Channel**: 메모리 컨트롤러 워드값을 CPU보다 크게 만들어 메모리 대역폭을 늘리는 기술
  - 램 여러 개 사용하는 것이 램 1개 사용하는 것보다 메모리 대역폭이 큼

- **정렬 제약 (alignment restriction)**: 데이터를 워드 크기에 맞춰 정렬해서 저장하는 방법
  - rgb는 3byte != 4byte → 버리거나, 투명도와 같이 다른 용도로 사용



## MIPS 특징

- 오퍼랜드가 대부분 3개 → 하드웨어 단순
- 레지스터가 32개 (32bit)
- 메모리 최대 1GB (2^30) 지원
- 워드값은 4byte (32bit)



## 리틀엔디안, 빅엔디안

: 메모리의 워드값을 어떤 값을 쓰는가에 따른 분류

- **빅 엔디안 (Big-endian, 표준)**: 높은 자리수(바이트)를 낮은 주소부터 저장 (→ 평소 숫자를 사용하는 선형 방식)

- **리틀 엔디안 (Little-endian)**: 높은 자리수(바이트)를 높은 주소부터 저장

![image](https://user-images.githubusercontent.com/70627979/179455528-334988e7-3d30-4a35-93e0-6ceb81f22ddf.png)



## 부호있는 수 vs 부호없는 수

- 2의 보수: 음수를 표현할 때, 1의 보수를 만들고 1을 더한 수
- 부호가 없으면 더 큰 수를 표현 가능
  - 1byte: unsigned(0~255), signed(-128~127)



## 명령어

### 명령어 형식 (instruction format)

#### MIPS 명령어 필드

- op: 연산자 (6bits)
- rs: 첫 번째 source 피연산자 레지스터 (5bits)
- rt: 두 번째 source 피연산자 레지스터 (5bits)
- rd: 목적지 레지스터 (5bits)
- shamt: shift 크기 (5bits)
- funct: function (6bits)



#### R타입, I타입

: 모든 명령어의 길이를 같게하되, 명령어의 종류에 따라 다른 형식을 사용

- **R 타입**
	
  | op (6) | rs (5) | rt (5) | rd (5) | shamt (5) | funct (6) |
  | :----: | :----: | :----: | :----: | :-------: | :-------: |
  
- **I 타입 (수치 연산, 데이터 전송 명령어)**

  | op (6) | rs (5) | rt (5) | constant or address (16) |
  | :----: | :----: | :----: | :----------------------: |

  

### 논리 연산 명령어

- **shift 연산자**

  - **sll(shift left logical)** 
    - 워드 내의 모든 비트를 왼쪽으로 이동시키고, 빈 자리는 0으로 채움
    - i번 이동: 2^i 곱하기

  - **srl(shift right logical)**
    - 워드 내의 모든 비트를 오른쪽으로 이동시키고, 빈 자리는 0으로 채움
    - i번 이동: 2^i 나누기

- **비트 연산자** 
  - **Bit Mask**: 특정 비트만 추출
  - **AND**: 둘 다 1인 경우에만, 1
  - **OR**: 둘 중에 하나라도 1이면, 1
  - **NOT**: 값을 반대로
  - **XOR**: 두 비트가 다르면, 1
  - **NOR**: 둘 중에 하나라도 1이면, 0 (= OR 결과를 NOT한 결과)
  - **NAND**: 둘 다 1인 경우에만, 0 (= AND 결과를 NOT한 결과)



### 판단 연산 명령어

- **beq(branch if equal)**
  - beq r1, r2, L1: r1와 r2가 같으면, L1으로 해당하는 문장으로 이동
- **bne(branch if not equal)**
  - bne r1, r2, L1: r1와 r2가 같지 않으면, L1으로 해당하는 문장으로 이동
- **j(jump)**
  - j Exit : if 문장의 끝부분으로 이동 (무조건 분기) 
- **slt(set on less than)**
  - slt $t0, $s3, $s4 : $s3가 $s4보다 작으면 t0은 1, 아니면 0 ($t0 = 1 if $s3 < $s4)
- **slti(set on less than instant)**
  - slt $t0, $s2, 10 : $s3가 10보다 작으면 t0은 1, 아니면 0 ($t0 = 1 if $s2 < 10)
  - 부호있는 정수
- **sltu(set on less than unsigned), sltiu**
  - 부호없는 정수



### 프로시저(Procedure)

: 제공되는 인수에 따라 특정 작업을 수행하는 서브루틴

- 프로시저를 위한 명령어

  - **jal (jump-and-link)**: 지정된 주소로 점프하면서, 동시에 다음 명령어의 주소를 레지스터에 저장하는 명령어

  - **jr (jump register)**: 레지스터에 저장된 주소로 무조건 점프하라는 명령어

- **PC (Program Counter) 레지스터**: 현재 위치
- **SP (Stack Pointer)**: 가장 최근에 스택에 할당된 주소를 가리키는 값



#### 스택, 힙

- 함수의 인자/리턴값은 스택에 저장 (호출이 끝나면 사라짐)
- 상대적으로 오래남는 값(전역변수 등)은 힙에 저장



#### 메모리 누출 (Memory Leak)

- 할당받은 메모리를 돌려주지 않고 리턴
- 해결 방안: Garbage Collection



### 문자/문자열

- ASCII
  - 숫자를 문자(알파벳+특수문자 등)로 해석
  - 1바이트 사용 (한글은 2바이트)
- 문자열
  - 문자열 앞에 길이 표시
  - 문자열의 끝을 표현하는 특수문자
- 유니코드
  - UTF-16
  - 모든 글자를 2바이트로 표현
- UTF-8
  - 1~4byte 멀티바이트 유니코드
  - 대역마다 2~4byte로 표현 (한글은 3byte)



#### 문자열 복사

문자열 복사 명령어

- **strcpy**: 경계값 취약점 O
- **strncpy**: 지정된 길이만큼 복사, 취약점 X
