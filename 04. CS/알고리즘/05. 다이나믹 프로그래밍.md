# 다이나믹 프로그래밍

큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘

- **조건**

  - 큰 문제를 작은 문제로 나눌 수 있다.

  - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

- **메모이제이션 기법**

  - 다이나믹 프로그래밍을 구현하는 방법 중 하나로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
  - 한 번 구한 정보를 리스트에 저장하여 구현



## 구분

- **탑다운(Top-Down) 방식**
  - 큰 문제를 해결하기 위해 작은 문제를 호출하는 방법
  - ex) 재귀 함수 이용
- **바텀업(Bottom-Up) 방식**
  - 작은 문제부터 답을 도출하는 방법
  - 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부름
  - ex) 반복문 이용



> - 다이나믹 프로그래밍과 분할-정복 알고리즘의 차이점
>
>   다이나믹 프로그래밍은 문제들이 서로 영향을 미치기 때문에 분할-정복 알고리즘과 다르게 한 번 해결했던 문제를 다시 해결한다는 점이 특징이다. (ex. 퀵 정렬 알고리즘)



## 예제

### 피보나치 수열

피보나치 수를 구하는 함수를 메모이제이션 없이 구현하면 n이 커지면 수행 시간이 기하급수적으로 늘어난다.

- 시간 복잡도가 O(2^N)

```js
// 💩
function fibo(x) {
  if(x === 1 || x === 2) {
    return 1;
  }
  
  return fibo(x - 1) + fibo(x - 2);
}
```



다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 리스트에서 그대로 가져와서 사용하여 문제를 해결할 수 있다.

- 시간 복잡도: O(N)

```js
// DP (재귀적, 탑다운)
const dpTable = Array(100).fill(0); // 100 이하의 피보나치 수를 구한다는 가정

function fibo(x) {
  if(x === 1 || x === 2) {
    return 1;
  }
  
  // 메모이제이션
  if(dpTable[x] !== 0) {
    return dpTable[x];
  }
  
  dpTable[x] = fibo(x - 1) + fibo(x - 2);

  return dpTable[x]
}
```



재귀 함수를 이용하면 컴퓨터 시스템에서 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다. 이는 재귀 함수 대신에 반복문을 사용하여 해결할 수 있다.

```js
// DP (반복문, 바텀업)
function fibo(x) {
  const dpTable = Array(100).fill(0); // 100 이하의 피보나치 수를 구한다는 가정

	dpTable[1] = 1;
	dpTable[2] = 1;
  
  for (let i = 3; i <= x; i++) {
    dpTable[i] = dpTable[i - 1] + dpTable[i - 2];
  }
  
  return dpTable[x]
}
```

